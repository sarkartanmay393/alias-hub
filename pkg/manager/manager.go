package manager

import (
	"fmt"
	"os"
	"path/filepath"
	"syscall"
	"time"

	"github.com/sarkartanmay393/ah/pkg/parser"
)

const (
	RootDirName  = ".ah"
	ActiveDir    = "active"
	BinDir       = "bin"
	StateFile    = "state"
	EnvFile      = "env.sh"
	RegistryRepo = "https://github.com/sarkartanmay393/ah" // Default
)

// ConflictError represents a conflict during installation
type ConflictError struct {
	Conflicts map[string]string
}

func (e *ConflictError) Error() string {
	return fmt.Sprintf("conflicts detected: %d aliases collide", len(e.Conflicts))
}

func GetRootDir() (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}
	return filepath.Join(home, RootDirName), nil
}

func EnsureDirs() error {
	root, err := GetRootDir()
	if err != nil {
		return err
	}

	dirs := []string{
		root,
		filepath.Join(root, ActiveDir),
		filepath.Join(root, BinDir),
	}

	for _, d := range dirs {
		if err := os.MkdirAll(d, 0755); err != nil {
			return err
		}
	}
	return GenerateEnvFile()
}

func GenerateEnvFile() error {
	root, err := GetRootDir()
	if err != nil {
		return err
	}

	envPath := filepath.Join(root, EnvFile)
	content := fmt.Sprintf(`#!/bin/sh
# Auto-generated by ah
AH_ROOT="%s"
AH_COMPILED="$AH_ROOT/aliases.compiled.sh"

# 1. Source Compiled Aliases
if [ -f "$AH_COMPILED" ]; then
  source "$AH_COMPILED"
fi

# 2. Define Live Update Hook
ah_check_state() {
	local state_file="$AH_ROOT/state"
	if [ -f "$state_file" ]; then
		# Cross-platform stat (BSD/Mac vs GNU/Linux)
		local current_mtime=""
		if stat -f "%%m" "$state_file" >/dev/null 2>&1; then
			current_mtime=$(stat -f "%%m" "$state_file")
		else
			current_mtime=$(stat -c "%%Y" "$state_file" 2>/dev/null)
		fi

		# If timestamp changed, re-source this file
		if [ -n "$current_mtime" ] && [ "$current_mtime" != "$AH_LAST_MTIME" ]; then
			export AH_LAST_MTIME="$current_mtime"
			source "$AH_ROOT/env.sh"
		fi
	fi
}

# 3. Register Hook
if [ -n "$ZSH_VERSION" ]; then
	autoload -Uz add-zsh-hook
	add-zsh-hook precmd ah_check_state
elif [ -n "$BASH_VERSION" ]; then
	if [[ "$PROMPT_COMMAND" != *"ah_check_state"* ]]; then
		PROMPT_COMMAND="ah_check_state; $PROMPT_COMMAND"
	fi
fi
`, root)

	if err := os.WriteFile(envPath, []byte(content), 0644); err != nil {
		return err
	}
	return TouchState()
}

// WithLock executes a function under a file lock
func WithLock(action func() error) error {
	root, err := GetRootDir()
	if err != nil {
		return err
	}

	lockPath := filepath.Join(root, ".lock")
	lockFile, err := os.OpenFile(lockPath, os.O_CREATE|os.O_RDWR, 0666)
	if err != nil {
		return err
	}
	defer lockFile.Close()

	if err := syscall.Flock(int(lockFile.Fd()), syscall.LOCK_EX); err != nil {
		return err
	}
	defer syscall.Flock(int(lockFile.Fd()), syscall.LOCK_UN)

	return action()
}

// TouchState updates the state file timestamp and re-compiles aliases.
// It uses WithLock internally.
func TouchState() error {
	return WithLock(func() error {
		// Performance: Re-compile aliases whenever state changes
		if err := CompileAliases(); err != nil {
			fmt.Printf("Warning: Failed to compile aliases: %v\n", err)
		}
		return updateStateTimestamp()
	})
}

// Internal helper (assumes lock is held)
func updateStateTimestamp() error {
	root, err := GetRootDir()
	if err != nil {
		return err
	}
	statePath := filepath.Join(root, StateFile)

	// Create if not exists, or update timestamp
	f, err := os.OpenFile(statePath, os.O_RDONLY|os.O_CREATE, 0644)
	if err != nil {
		return err
	}
	f.Close()

	now := time.Now()
	return os.Chtimes(statePath, now, now)
}

// CheckConflicts returns a list of conflicts (alias name -> existing source)
func CheckConflicts(newPackagePath string) (map[string]string, error) {
	newAliases, err := parser.ParseAliases(filepath.Join(newPackagePath, "alias.sh"))
	if err != nil {
		// If alias.sh doesn't exist or weird format, just skip conflict check for now
		return nil, nil // non-fatal
	}

	conflicts := make(map[string]string)

	// Scan active packages
	root, _ := GetRootDir()
	activeDir := filepath.Join(root, ActiveDir)
	entries, _ := os.ReadDir(activeDir)

	for _, entry := range entries {
		pkgPath := filepath.Join(activeDir, entry.Name(), "alias.sh")
		existingAliases, _ := parser.ParseAliases(pkgPath)

		for _, exist := range existingAliases {
			for _, newA := range newAliases {
				if exist.Name == newA.Name {
					conflicts[exist.Name] = entry.Name()
				}
			}
		}
	}

	if len(conflicts) > 0 {
		return conflicts, nil
	}
	return nil, nil
}
